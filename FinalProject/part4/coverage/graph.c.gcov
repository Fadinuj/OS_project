        -:    0:Source:../part2/graph.c
        -:    0:Graph:random-graph.gcno
        -:    0:Data:random-graph.gcda
        -:    0:Runs:23
        -:    1:#include "graph.h"
        -:    2:#include <stdio.h>
        -:    3:#include <unistd.h> 
        -:    4:#include <stdlib.h>
        -:    5:
        -:    6:
        -:    7:/**
        -:    8: * Check if vertex index v is within [0, g->n).
        -:    9: * @param g Graph pointer (may be NULL).
        -:   10: * @param v Vertex index to check.
        -:   11: * @return Non-zero if valid; 0 otherwise.
        -:   12: */
     1776:   13:static int in_bounds(const Graph* g, int v) {
    1776*:   14:    return (g != NULL && v >= 0 && v < g->n);
        -:   15:}
        -:   16:
        -:   17:/**
        -:   18: * Count how many times v appears in u's adjacency list.
        -:   19: * @param g Graph pointer (non-NULL).
        -:   20: * @param u Source vertex.
        -:   21: * @param v Neighbor to count in u's list.
        -:   22: * @return Number of occurrences of v in u's adjacency list.
        -:   23: */
        -:   24:
      888:   25:static int count_neighbor(const Graph* g, int u, int v){
      888:   26:    int c = 0;
     9297:   27:    for (EdgeNode* e = g->adj[u].head; e; e = e->next)
     8409:   28:        if (e->to == v) c++;
      888:   29:    return c;
        -:   30:}
        -:   31:
        -:   32:
        -:   33:/**
        -:   34: * Simple-graph duplicate check for undirected edge (u--v).
        -:   35: *  - For u!=v: if u->v appears at least once, the undirected edge exists.
        -:   36: *  - For u==v: one self-loop is represented by two u->u entries; if already 2, reject.
        -:   37: * @param g Graph pointer (non-NULL).
        -:   38: * @param u First vertex.
        -:   39: * @param v Second vertex.
        -:   40: * @return Non-zero if the (undirected) edge already exists under the policy; 0 otherwise.
        -:   41: */
        -:   42:
      888:   43:static int edge_exists_simple(const Graph* g, int u, int v){
      888:   44:    if (u == v) return count_neighbor(g, u, u) >= 2;
      832:   45:    return count_neighbor(g, u, v) >= 1;
        -:   46:}
        -:   47:
        -:   48:/**
        -:   49: * Create a graph with n vertices and no edges.
        -:   50: * @param n Number of vertices (must be > 0).
        -:   51: * @return Pointer to a new Graph, or NULL if n<=0 or allocation fails.
        -:   52: */
       15:   53:Graph* graph_create(int n) {
      15*:   54:    if (n <= 0) return NULL;
        -:   55:
       15:   56:    Graph* g = (Graph*)malloc(sizeof(Graph));
      15*:   57:    if (!g) return NULL;
        -:   58:
       15:   59:    g->n = n;
       15:   60:    g->adj = (Vertex*)calloc((size_t)n, sizeof(Vertex));
      15*:   61:    if (!g->adj) { free(g); return NULL; }
        -:   62:
       15:   63:    return g;
        -:   64:}
        -:   65:
        -:   66:/**
        -:   67: * Destroy a graph and free all associated memory (safe for NULL).
        -:   68: * @param g Graph pointer (may be NULL).
        -:   69: */
       15:   70:void graph_destroy(Graph* g) {
      15*:   71:    if (!g) return;
      141:   72:    for (int i = 0; i < g->n; ++i) {
      126:   73:        EdgeNode* cur = g->adj[i].head;
     1000:   74:        while (cur) {
      874:   75:            EdgeNode* tmp = cur;
      874:   76:            cur = cur->next;
      874:   77:            free(tmp);
        -:   78:        }
        -:   79:    }
       15:   80:    free(g->adj);
       15:   81:    free(g);
        -:   82:}
        -:   83:
        -:   84:/**
        -:   85: * Add an undirected edge u--v under the simple-graph policy.
        -:   86: * Allocates two adjacency nodes (u->v) and (v->u) on success.         
        -:   87: * Rejects duplicates and a second self-loop.
        -:   88: * @param g Graph pointer (non-NULL).
        -:   89: * @param u Vertex index in [0,n-1].
        -:   90: * @param v Vertex index in [0,n-1].
        -:   91: * @return 0 on success; -1 out of bounds; -2 OOM; -3 duplicate/second self-loop.
        -:   92: */
      888:   93:int graph_add_edge(Graph* g, int u, int v) {
     888*:   94:    if (!in_bounds(g, u) || !in_bounds(g, v)) return -1;
        -:   95:
      888:   96:    if (edge_exists_simple(g, u, v)) return -3;
        -:   97:
      437:   98:    if (u == v) {
       36:   99:        EdgeNode* e1 = (EdgeNode*)malloc(sizeof(EdgeNode));
       36:  100:        EdgeNode* e2 = (EdgeNode*)malloc(sizeof(EdgeNode));
      36*:  101:        if (!e1 || !e2) { free(e1); free(e2); return -2; }
       36:  102:        e1->to = u;
       36:  103:        e1->next = g->adj[u].head;  
       36:  104:        e2->to = u;
       36:  105:        e2->next = e1;            
       36:  106:        g->adj[u].head = e2;       
       36:  107:        return 0;
        -:  108:    } else {
      401:  109:        EdgeNode* e1 = (EdgeNode*)malloc(sizeof(EdgeNode));
      401:  110:        EdgeNode* e2 = (EdgeNode*)malloc(sizeof(EdgeNode));
     401*:  111:        if (!e1 || !e2) { free(e1); free(e2); return -2; }
        -:  112:
      401:  113:        e1->to = v; e1->next = g->adj[u].head;
      401:  114:        e2->to = u; e2->next = g->adj[v].head;
        -:  115:
      401:  116:        g->adj[u].head = e1;
      401:  117:        g->adj[v].head = e2;
      401:  118:        return 0;
        -:  119:    }
        -:  120:}
        -:  121:
        -:  122:
        -:  123:/**
        -:  124: *  Print adjacency lists to stdout. One line per vertex.
        -:  125: * @param g Graph pointer (NULL is ignored).
        -:  126: */
       15:  127:void graph_print(const Graph* g) {
      15*:  128:    if (!g) return;
      141:  129:    for (int i = 0; i < g->n; ++i) {
      126:  130:        printf("%d:", i);
     1000:  131:        for (EdgeNode* cur = g->adj[i].head; cur; cur = cur->next) {
      874:  132:            printf(" %d", cur->to);
        -:  133:        }
      126:  134:        printf("\n");
        -:  135:    }
        -:  136:}
        -:  137:
        -:  138:/**
        -:  139: * 
        -:  140: * Vec
        -:  141: *   A tiny dynamic array of int.
        -:  142: *   Used as:
        -:  143:    - a stack during the Hierholzer walk,
        -:  144:     - the output path buffer,
        -:  145:     - per-vertex incidence lists (incid[v]) in EdgeView.
        -:  146: *   Fields:
        -:  147: *     - a   : pointer to the storage (int*), or NULL when empty
        -:  148: *     - n   : current number of elements
        -:  149: *     - cap : current capacity (>= n), 0 when empty
        -:  150: 1.  v_reserve(Vec* v, int cap)
        -:  151: *   Ensures the vector has at least 'cap' capacity.
        -:  152: *   Grows geometrically (×2, min 16). On failure, 'v' is unchanged.
        -:  153: *   Returns: 0 on success; -1 on allocation failure.
        -:  154: 2.  v_push(Vec* v, int x)
        -:  155: *   Appends 'x' to the end of the vector, growing if needed.
        -:  156: *   Returns: 0 on success; -1 on allocation failure.
        -:  157: 3. v_pop(Vec* v)
        -:  158: *   Removes and returns the last element.
        -:  159: 4. v_back(const Vec* v)
        -:  160: *   Returns (without removing) the last element.
        -:  161: 5. v_free(Vec* v)
        -:  162: *   Frees the storage and resets the vector to an empty state:
        -:  163: *   a = NULL, n = 0, cap = 0.
        -:  164: 6. v_reverse(Vec* v)
        -:  165: *   Reverses the elements in place.
        -:  166: */
        -:  167:typedef struct { int *a; int n, cap; } Vec;
     154*:  168:static int  v_reserve(Vec* v, int cap){ if (cap<=v->cap) return 0; int c=v->cap? v->cap*2:16; if(c<cap) c=cap; int*na=(int*)realloc(v->a, sizeof(int)*c); if(!na) return -1; v->a=na; v->cap=c; return 0; }
     154*:  169:static int  v_push(Vec* v, int x){ if(v_reserve(v,v->n+1)) return -1; v->a[v->n++]=x; return 0; }
      131:  170:static int  v_pop (Vec* v){ return v->a[--v->n]; }
       16:  171:static int  v_back(const Vec* v){ return v->a[v->n-1]; }
       22:  172:static void v_free(Vec* v){ free(v->a); v->a=NULL; v->n=v->cap=0; }
        6:  173:static void v_reverse(Vec* v){ for(int i=0,j=v->n-1;i<j;i++,j--){ int t=v->a[i]; v->a[i]=v->a[j]; v->a[j]=t; } }
        -:  174:/**
        -:  175: * EdgeView
        -:  176: * A temporary, deduplicated “edge view” used by Hierholzer’s algorithm so  each undirected edge has a single ID and can be marked as used once.
        -:  177: *Fields:
        -:  178: *-edges : array of UEEdge (length m), each edge appears exactly once
        -:  179: *- m     : number of undirected edges
        -:  180: *- incid : array (length n) of Vec; incid[x] holds indices of edges that touch vertex x
        -:  181: *- n     : number of vertices
        -:  182: * For a normal edge u--v: insert exactly once (typically when u < v),     and append its index to incid[u] and incid[v].
        -:  183: * For a self-loop u==v: pair the two adjacency entries (u->u, u->u)
        -:  184: into one UEEdge {u,u}, and append that edge index twice to incid[u]
        -:  185: (so the loop contributes degree +2 and is discoverable from u).
        -:  186: */
        -:  187:typedef struct { int u, v; } UEEdge;
        -:  188:typedef struct {
        -:  189:    UEEdge* edges; int m;  
        -:  190:    Vec* incid;   int n;   
        -:  191:} EdgeView;
        -:  192:
        -:  193:/**
        -:  194: * Free all allocations owned by an EdgeView.
        -:  195: * @param ev EdgeView pointer.
        -:  196: */
        2:  197:static void ev_free(EdgeView* ev){
       2*:  198:    if(!ev) return;
        6:  199:    for(int i=0;i<ev->n;i++) v_free(&ev->incid[i]);
        2:  200:    free(ev->incid);
        2:  201:    free(ev->edges);
        -:  202:}
        -:  203:
        -:  204:/**
        -:  205: * Compute degree of vertex v from adjacency lists.
        -:  206: * A self-loop contributes +2 (since two u->u entries are stored).
        -:  207: * @param g Graph pointer.
        -:  208: * @param v Vertex index.
        -:  209: * @return Degree of v.
        -:  210: */
      174:  211:static int degree_vertex_adj(const Graph* g, int v){
     1223:  212:    int d=0; for(EdgeNode* e=g->adj[v].head; e; e=e->next) d++;
      174:  213:    return d; 
        -:  214:}
        -:  215:
        -:  216:/**
        -:  217: * Check connectivity ignoring isolated vertices.
        -:  218: * Returns 1 if all vertices with degree>0 belong to a single connected         component (or if the graph has no edges); 0 otherwise.
        -:  219: * @param g Graph pointer.
        -:  220: * @return 1 if connected (ignoring isolated) or no edges; 0 otherwise.
        -:  221: */
       17:  222:static int is_connected_ignore_isolated(const Graph* g){
       17:  223:    int start = -1;
       20:  224:    for(int i=0;i<g->n;i++)
       19:  225:        if (degree_vertex_adj(g,i)>0) { start=i; break; }
       17:  226:    if (start==-1) return 1;
        -:  227:
       16:  228:    char* vis = (char*)calloc((size_t)g->n, 1);
      16*:  229:    if(!vis) return 0;
       16:  230:    Vec st={0};
       16:  231:    (void)v_push(&st, start); vis[start]=1;
        -:  232:
      138:  233:    while(st.n){
      122:  234:        int u = v_pop(&st);
     1008:  235:        for(EdgeNode* e=g->adj[u].head; e; e=e->next){
      886:  236:            int v = e->to;
      886:  237:            if(!vis[v]){ vis[v]=1; (void)v_push(&st, v); }
        -:  238:        }
        -:  239:    }
       16:  240:    int ok=1;
      143:  241:    for(int i=0;i<g->n;i++)
      128:  242:        if (degree_vertex_adj(g,i)>0 && !vis[i]) { ok=0; break; }
        -:  243:
       16:  244:    v_free(&st); free(vis);
       16:  245:    return ok;
        -:  246:}
        -:  247:
        -:  248:/**
        -:  249: *  Build an EdgeView from adjacency lists.
        -:  250: *  - Pairs every two u->u directed entries into a single undirected loop (u,u)
        -:  251: *    and pushes that edge index twice into incid[u].
        -:  252: *  - For u!=v, inserts edge (min,max) exactly once and adds its index to
        -:  253: *    both incid[u] and incid[v].
        -:  254: * @param g Graph pointer.
        -:  255: * @param ev OUT: EdgeView to fill.
        -:  256: * @return 0 on success; -1 on allocation failure (ev is cleaned up).
        -:  257: */
        2:  258:static int build_edge_view(const Graph* g, EdgeView* ev){
        2:  259:    ev->n = g->n;
        2:  260:    ev->edges = NULL; ev->m = 0;
        2:  261:    ev->incid = (Vec*)calloc((size_t)ev->n, sizeof(Vec));
       2*:  262:    if(!ev->incid) return -1;
        -:  263:
        2:  264:    long long sumdeg = 0;
        6:  265:    for(int u=0; u<g->n; ++u)
       18:  266:        for(EdgeNode* e=g->adj[u].head; e; e=e->next) sumdeg++;
        2:  267:    int m_est = (int)(sumdeg/2 + 1);
        -:  268:
        2:  269:    ev->edges = (UEEdge*)malloc(sizeof(UEEdge) * (size_t)m_est);
       2*:  270:    if(!ev->edges){ ev_free(ev); return -1; }
        -:  271:
        2:  272:    int* loop_half = (int*)calloc((size_t)ev->n, sizeof(int));
       2*:  273:    if(!loop_half){ ev_free(ev); return -1; }
        -:  274:
        6:  275:    for(int u=0; u<g->n; ++u){
       18:  276:        for(EdgeNode* e=g->adj[u].head; e; e=e->next){
       14:  277:            int v = e->to;
        -:  278:
       14:  279:            if (u == v) {
        8:  280:                if ((++loop_half[u] & 1) == 0) {
        4:  281:                    if(ev->m == m_est){
    #####:  282:                        m_est = m_est ? m_est*2 : 16;
    #####:  283:                        UEEdge* ne = (UEEdge*)realloc(ev->edges, sizeof(UEEdge)*(size_t)m_est);
    #####:  284:                        if(!ne){ 
    #####:  285:                            free(loop_half);
    #####:  286:                             ev_free(ev); 
    #####:  287:                             return -1; 
        -:  288:                        }
    #####:  289:                        ev->edges = ne;
        -:  290:                    }
        4:  291:                    ev->edges[ev->m] = (UEEdge){u,u};
        4:  292:                    if (v_push(&ev->incid[u], ev->m) || v_push(&ev->incid[u], ev->m)) {
    #####:  293:                        free(loop_half); ev_free(ev); return -1;
        -:  294:                    }
        4:  295:                    ev->m++;
        -:  296:                }
        6:  297:            } else if (u < v) {
        3:  298:                if(ev->m == m_est){
    #####:  299:                    m_est = m_est ? m_est*2 : 16;
    #####:  300:                    UEEdge* ne = (UEEdge*)realloc(ev->edges, sizeof(UEEdge)*(size_t)m_est);
    #####:  301:                    if(!ne){ free(loop_half); ev_free(ev); return -1; }
    #####:  302:                    ev->edges = ne;
        -:  303:                }
        3:  304:                ev->edges[ev->m] = (UEEdge){u,v};
        3:  305:                if (v_push(&ev->incid[u], ev->m) || v_push(&ev->incid[v], ev->m)) {
    #####:  306:                    free(loop_half); ev_free(ev); return -1;
        -:  307:                }
        3:  308:                ev->m++;
        -:  309:            }
        -:  310:        }
        -:  311:    }
        2:  312:    free(loop_half);
        2:  313:    return 0;
        -:  314:}
        -:  315:
        -:  316:/**
        -:  317: * @brief Check if the graph has an Euler circuit (undirected).
        -:  318: * @details Returns 1 if
        -:  319: *  - the subgraph induced by vertices of degree>0 is connected, and
        -:  320: *  - all vertex degrees are even, and
        -:  321: *  - there is at least one edge.
        -:  322: * @param g Graph pointer.
        -:  323: * @return 1 if Euler circuit exists, else 0.
        -:  324: */
       17:  325:int graph_has_euler_circuit(const Graph* g){
      17*:  326:    if (!g) return 0;
        -:  327:
       17:  328:    if (!is_connected_ignore_isolated(g)) return 0;
        -:  329:
       16:  330:    long long sumdeg = 0;
       32:  331:    for (int i = 0; i < g->n; ++i){
       27:  332:        int d = degree_vertex_adj(g, i);
       27:  333:        if (d % 2 != 0) return 0;
       16:  334:        sumdeg += d;
        -:  335:    }
        5:  336:    if (sumdeg == 0) return 0; 
        -:  337:
        4:  338:    return 1;
        -:  339:}
        -:  340:
        -:  341:
        -:  342:
        -:  343:/**
        -:  344: *  Find an Euler circuit using Hierholzer's algorithm.
        -:  345: *  - Builds an EdgeView and maintains:
        -:  346: *      used[m] to mark used edges,
        -:  347: *      it[n]  as per-vertex iterator over incid lists,
        -:  348: *      stack  for the forward walk,
        -:  349: *      path   to collect the final circuit in reverse.
        -:  350: *  - When a vertex has no more unused incident edges, it is popped to path.
        -:  351: *  - Finally, path is reversed to obtain the circuit order.
        -:  352: * @param g Graph pointer.
        -:  353: * @param out_cycle OUT: allocated array of vertices in order (caller frees).
        -:  354: * @param out_len   OUT: number of vertices in out_cycle (should be m+1).
        -:  355: * @return 1 on success; 0 if no Euler circuit or on failure.
        -:  356: */
        -:  357:
        2:  358:int graph_find_euler_circuit(const Graph* g, int** out_cycle, int* out_len){
       2*:  359:    if (!g || !out_cycle || !out_len) return 0;
        2:  360:    *out_cycle = NULL; *out_len = 0;
        -:  361:
       2*:  362:    if (!graph_has_euler_circuit(g)) return 0;
        -:  363:
       2*:  364:    EdgeView ev; if (build_edge_view(g, &ev)) return 0;
        -:  365:
        2:  366:    int start = -1;
       2*:  367:    for (int i = 0; i < ev.n; ++i){
        2:  368:        if (ev.incid[i].n > 0) { start = i; break; }
        -:  369:    }
       2*:  370:    if (start == -1) { ev_free(&ev); return 0; }
        -:  371:
        2:  372:    int* used = (int*)calloc((size_t)ev.m, sizeof(int));
        2:  373:    int* it   = (int*)calloc((size_t)ev.n, sizeof(int));
       2*:  374:    if(!used || !it){ free(used); free(it); ev_free(&ev); return 0; }
        -:  375:
        2:  376:    Vec stack={0}, path={0};
        2:  377:    (void)v_push(&stack, start);
        -:  378:
       18:  379:    while (stack.n){
       16:  380:        int u = v_back(&stack);
        -:  381:
       23:  382:        while (it[u] < ev.incid[u].n && used[ ev.incid[u].a[it[u]] ]) it[u]++;
        -:  383:
       16:  384:        if (it[u] == ev.incid[u].n){
        9:  385:            (void)v_push(&path, u);
        9:  386:            (void)v_pop(&stack);
        -:  387:        } else {
        7:  388:            int ei = ev.incid[u].a[it[u]++];
        7:  389:            if (!used[ei]) {
        7:  390:                used[ei] = 1;
        7:  391:                int a = ev.edges[ei].u, b = ev.edges[ei].v;
        7:  392:                int v = (u==a) ? b : a;
        7:  393:                (void)v_push(&stack, v);
        -:  394:            }
        -:  395:        }
        -:  396:    }
        -:  397:
        2:  398:    v_reverse(&path);
        -:  399:
        2:  400:    free(used); free(it);
        2:  401:    ev_free(&ev);
        2:  402:    v_free(&stack);
        -:  403:
       2*:  404:    if (path.n < 1) { v_free(&path); return 0; }
        -:  405:
        2:  406:    *out_cycle = path.a; 
        2:  407:    *out_len   = path.n;
        -:  408:
        2:  409:    return 1;
        -:  410:}
