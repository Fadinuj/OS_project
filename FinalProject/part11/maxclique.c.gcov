        -:    0:Source:../part7/maxclique.c
        -:    0:Graph:../part7/maxclique.gcno
        -:    0:Data:../part7/maxclique.gcda
        -:    0:Runs:2
        -:    1:#include "maxclique.h"
        -:    2:#include <stdio.h>
        -:    3:#include <stdlib.h>
        -:    4:#include <string.h>
        -:    5:
        -:    6:/**
        -:    7: * Build adjacency matrix from adjacency list for efficient clique checking.
        -:    8: */
    #####:    9:static int build_adjacency_matrix(const Graph* g, int** adj_matrix) {
    #####:   10:    int n = g->n;
        -:   11:    
        -:   12:    // Initialize matrix to 0
    #####:   13:    for (int i = 0; i < n; i++) {
    #####:   14:        for (int j = 0; j < n; j++) {
    #####:   15:            adj_matrix[i][j] = 0;
        -:   16:        }
        -:   17:    }
        -:   18:    
        -:   19:    // Fill adjacency matrix
    #####:   20:    for (int u = 0; u < n; u++) {
    #####:   21:        for (EdgeNode* edge = g->adj[u].head; edge; edge = edge->next) {
    #####:   22:            int v = edge->to;
    #####:   23:            if (u != v) { // Skip self-loops
    #####:   24:                adj_matrix[u][v] = 1;
        -:   25:            }
        -:   26:        }
        -:   27:    }
        -:   28:    
    #####:   29:    return 1;
        -:   30:}
        -:   31:
        -:   32:/**
        -:   33: * Check if vertex v is connected to all vertices in current clique.
        -:   34: */
    #####:   35:static int is_connected_to_all(int** adj_matrix, int v, int* current_clique, int clique_size) {
    #####:   36:    for (int i = 0; i < clique_size; i++) {
    #####:   37:        if (!adj_matrix[v][current_clique[i]]) {
    #####:   38:            return 0;
        -:   39:        }
        -:   40:    }
    #####:   41:    return 1;
        -:   42:}
        -:   43:
        -:   44:/**
        -:   45: * Backtracking algorithm to find maximum clique.
        -:   46: */
    #####:   47:static void max_clique_backtrack(int** adj_matrix, int n, int start_vertex,
        -:   48:                                int* current_clique, int current_size,
        -:   49:                                int* best_clique, int* best_size) {
        -:   50:    
        -:   51:    // Update best clique if current is larger
    #####:   52:    if (current_size > *best_size) {
    #####:   53:        *best_size = current_size;
    #####:   54:        for (int i = 0; i < current_size; i++) {
    #####:   55:            best_clique[i] = current_clique[i];
        -:   56:        }
        -:   57:    }
        -:   58:    
        -:   59:    // Try adding each remaining vertex
    #####:   60:    for (int v = start_vertex; v < n; v++) {
        -:   61:        // Check if v is connected to all vertices in current clique
    #####:   62:        if (is_connected_to_all(adj_matrix, v, current_clique, current_size)) {
        -:   63:            // Add v to current clique
    #####:   64:            current_clique[current_size] = v;
        -:   65:            
        -:   66:            // Recursive call
    #####:   67:            max_clique_backtrack(adj_matrix, n, v + 1, 
        -:   68:                               current_clique, current_size + 1,
        -:   69:                               best_clique, best_size);
        -:   70:        }
        -:   71:    }
    #####:   72:}
        -:   73:
        -:   74:/**
        -:   75: * Find maximum clique using backtracking algorithm.
        -:   76: */
    #####:   77:int graph_max_clique(const Graph* g, MaxClique_Result* result) {
    #####:   78:    if (!g || !result) return 0;
        -:   79:    
    #####:   80:    int n = g->n;
        -:   81:    
        -:   82:    // Initialize result
    #####:   83:    result->vertices = NULL;
    #####:   84:    result->size = 0;
    #####:   85:    result->is_valid = 0;
        -:   86:    
    #####:   87:    if (n == 0) {
    #####:   88:        result->is_valid = 1;
    #####:   89:        return 1;
        -:   90:    }
        -:   91:    
        -:   92:    // Single vertex is always a clique of size 1
    #####:   93:    if (n == 1) {
    #####:   94:        result->vertices = (int*)malloc(sizeof(int));
    #####:   95:        if (!result->vertices) return 0;
    #####:   96:        result->vertices[0] = 0;
    #####:   97:        result->size = 1;
    #####:   98:        result->is_valid = 1;
    #####:   99:        return 1;
        -:  100:    }
        -:  101:    
        -:  102:    // Allocate adjacency matrix
    #####:  103:    int** adj_matrix = (int**)malloc(n * sizeof(int*));
    #####:  104:    if (!adj_matrix) return 0;
        -:  105:    
    #####:  106:    for (int i = 0; i < n; i++) {
    #####:  107:        adj_matrix[i] = (int*)malloc(n * sizeof(int));
    #####:  108:        if (!adj_matrix[i]) {
    #####:  109:            for (int j = 0; j < i; j++) free(adj_matrix[j]);
    #####:  110:            free(adj_matrix);
    #####:  111:            return 0;
        -:  112:        }
        -:  113:    }
        -:  114:    
        -:  115:    // Build adjacency matrix
    #####:  116:    build_adjacency_matrix(g, adj_matrix);
        -:  117:    
        -:  118:    // Allocate working arrays
    #####:  119:    int* current_clique = (int*)malloc(n * sizeof(int));
    #####:  120:    int* best_clique = (int*)malloc(n * sizeof(int));
        -:  121:    
    #####:  122:    if (!current_clique || !best_clique) {
    #####:  123:        free(current_clique); free(best_clique);
    #####:  124:        for (int i = 0; i < n; i++) free(adj_matrix[i]);
    #####:  125:        free(adj_matrix);
    #####:  126:        return 0;
        -:  127:    }
        -:  128:    
    #####:  129:    int best_size = 0;
        -:  130:    
        -:  131:    // Try starting from each vertex
    #####:  132:    for (int start = 0; start < n; start++) {
    #####:  133:        current_clique[0] = start;
    #####:  134:        max_clique_backtrack(adj_matrix, n, start + 1,
        -:  135:                           current_clique, 1,
        -:  136:                           best_clique, &best_size);
        -:  137:    }
        -:  138:    
        -:  139:    // Store result
    #####:  140:    if (best_size > 0) {
    #####:  141:        result->vertices = (int*)malloc(best_size * sizeof(int));
    #####:  142:        if (!result->vertices) {
    #####:  143:            free(current_clique); free(best_clique);
    #####:  144:            for (int i = 0; i < n; i++) free(adj_matrix[i]);
    #####:  145:            free(adj_matrix);
    #####:  146:            return 0;
        -:  147:        }
        -:  148:        
    #####:  149:        for (int i = 0; i < best_size; i++) {
    #####:  150:            result->vertices[i] = best_clique[i];
        -:  151:        }
    #####:  152:        result->size = best_size;
    #####:  153:        result->is_valid = 1;
        -:  154:    }
        -:  155:    
        -:  156:    // Cleanup
    #####:  157:    free(current_clique); free(best_clique);
    #####:  158:    for (int i = 0; i < n; i++) free(adj_matrix[i]);
    #####:  159:    free(adj_matrix);
        -:  160:    
    #####:  161:    return 1;
        -:  162:}
        -:  163:
        -:  164:/**
        -:  165: * Print max clique result in a formatted way.
        -:  166: */
    #####:  167:void graph_print_max_clique(const Graph* g) {
    #####:  168:    if (!g) {
    #####:  169:        printf("Error: NULL graph\n");
    #####:  170:        return;
        -:  171:    }
        -:  172:    
        -:  173:    MaxClique_Result result;
    #####:  174:    if (!graph_max_clique(g, &result)) {
    #####:  175:        printf("Error: Failed to calculate max clique\n");
    #####:  176:        return;
        -:  177:    }
        -:  178:    
    #####:  179:    if (!result.is_valid || result.size == 0) {
    #####:  180:        printf("No clique found\n");
    #####:  181:        maxclique_result_free(&result);
    #####:  182:        return;
        -:  183:    }
        -:  184:    
    #####:  185:    printf("Maximum Clique:\n");
    #####:  186:    printf("Size: %d\n", result.size);
    #####:  187:    printf("Vertices: {");
    #####:  188:    for (int i = 0; i < result.size; i++) {
    #####:  189:        printf("%d", result.vertices[i]);
    #####:  190:        if (i < result.size - 1) printf(", ");
        -:  191:    }
    #####:  192:    printf("}\n");
        -:  193:    
        -:  194:    // Verify it's actually a clique
    #####:  195:    if (graph_is_clique(g, result.vertices, result.size)) {
    #####:  196:        printf("✓ Verified: This is a valid clique\n");
        -:  197:    } else {
    #####:  198:        printf("✗ Error: This is not a valid clique!\n");
        -:  199:    }
        -:  200:    
    #####:  201:    maxclique_result_free(&result);
        -:  202:}
        -:  203:
        -:  204:/**
        -:  205: * Free max clique result memory.
        -:  206: */
    #####:  207:void maxclique_result_free(MaxClique_Result* result) {
    #####:  208:    if (result && result->vertices) {
    #####:  209:        free(result->vertices);
    #####:  210:        result->vertices = NULL;
    #####:  211:        result->size = 0;
    #####:  212:        result->is_valid = 0;
        -:  213:    }
    #####:  214:}
        -:  215:
        -:  216:/**
        -:  217: * Get max clique size only (simpler interface).
        -:  218: */
    #####:  219:int graph_max_clique_size(const Graph* g, int* clique_size) {
    #####:  220:    if (!g || !clique_size) return 0;
        -:  221:    
        -:  222:    MaxClique_Result result;
    #####:  223:    if (!graph_max_clique(g, &result)) {
    #####:  224:        return 0;
        -:  225:    }
        -:  226:    
    #####:  227:    if (!result.is_valid) {
    #####:  228:        maxclique_result_free(&result);
    #####:  229:        return 0;
        -:  230:    }
        -:  231:    
    #####:  232:    *clique_size = result.size;
    #####:  233:    maxclique_result_free(&result);
    #####:  234:    return 1;
        -:  235:}
        -:  236:
        -:  237:/**
        -:  238: * Check if a given set of vertices forms a clique.
        -:  239: */
    #####:  240:int graph_is_clique(const Graph* g, int* vertices, int size) {
    #####:  241:    if (!g || !vertices || size < 0) return 0;
        -:  242:    
    #####:  243:    if (size <= 1) return 1; // Single vertex or empty set is trivially a clique
        -:  244:    
    #####:  245:    int n = g->n;
        -:  246:    
        -:  247:    // Check if all vertices are valid
    #####:  248:    for (int i = 0; i < size; i++) {
    #####:  249:        if (vertices[i] < 0 || vertices[i] >= n) return 0;
        -:  250:    }
        -:  251:    
        -:  252:    // Build adjacency matrix
    #####:  253:    int** adj_matrix = (int**)malloc(n * sizeof(int*));
    #####:  254:    if (!adj_matrix) return 0;
        -:  255:    
    #####:  256:    for (int i = 0; i < n; i++) {
    #####:  257:        adj_matrix[i] = (int*)malloc(n * sizeof(int));
    #####:  258:        if (!adj_matrix[i]) {
    #####:  259:            for (int j = 0; j < i; j++) free(adj_matrix[j]);
    #####:  260:            free(adj_matrix);
    #####:  261:            return 0;
        -:  262:        }
        -:  263:    }
        -:  264:    
    #####:  265:    build_adjacency_matrix(g, adj_matrix);
        -:  266:    
        -:  267:    // Check if every pair of vertices is connected
    #####:  268:    int is_clique = 1;
    #####:  269:    for (int i = 0; i < size && is_clique; i++) {
    #####:  270:        for (int j = i + 1; j < size && is_clique; j++) {
    #####:  271:            if (!adj_matrix[vertices[i]][vertices[j]]) {
    #####:  272:                is_clique = 0;
        -:  273:            }
        -:  274:        }
        -:  275:    }
        -:  276:    
        -:  277:    // Cleanup
    #####:  278:    for (int i = 0; i < n; i++) free(adj_matrix[i]);
    #####:  279:    free(adj_matrix);
        -:  280:    
    #####:  281:    return is_clique;
        -:  282:}
        -:  283:
        -:  284:/**
        -:  285: * Bron-Kerbosch algorithm for finding all maximal cliques (simplified version).
        -:  286: * Note: This is a basic implementation. For large graphs, optimizations are needed.
        -:  287: */
    #####:  288:static void bron_kerbosch(int** adj_matrix, int n,
        -:  289:                         int* R, int R_size,          // Current clique
        -:  290:                         int* P, int P_size,          // Candidate vertices
        -:  291:                         int* X, int X_size,          // Excluded vertices
        -:  292:                         MaxClique_Result** results, int* num_results, int* capacity) {
        -:  293:    
    #####:  294:    if (P_size == 0 && X_size == 0) {
        -:  295:        // Found a maximal clique
    #####:  296:        if (*num_results >= *capacity) {
    #####:  297:            *capacity *= 2;
    #####:  298:            *results = (MaxClique_Result*)realloc(*results, *capacity * sizeof(MaxClique_Result));
    #####:  299:            if (!*results) return;
        -:  300:        }
        -:  301:        
    #####:  302:        (*results)[*num_results].vertices = (int*)malloc(R_size * sizeof(int));
    #####:  303:        if (!(*results)[*num_results].vertices) return;
        -:  304:        
    #####:  305:        for (int i = 0; i < R_size; i++) {
    #####:  306:            (*results)[*num_results].vertices[i] = R[i];
        -:  307:        }
    #####:  308:        (*results)[*num_results].size = R_size;
    #####:  309:        (*results)[*num_results].is_valid = 1;
    #####:  310:        (*num_results)++;
    #####:  311:        return;
        -:  312:    }
        -:  313:    
        -:  314:    // Make copies of P for iteration
    #####:  315:    int* P_copy = (int*)malloc(P_size * sizeof(int));
    #####:  316:    if (!P_copy) return;
    #####:  317:    for (int i = 0; i < P_size; i++) P_copy[i] = P[i];
    #####:  318:    int P_copy_size = P_size;
        -:  319:    
    #####:  320:    for (int i = 0; i < P_copy_size; i++) {
    #####:  321:        int v = P_copy[i];
        -:  322:        
        -:  323:        // R' = R ∪ {v}
    #####:  324:        R[R_size] = v;
        -:  325:        
        -:  326:        // P' = P ∩ N(v)
    #####:  327:        int* P_new = (int*)malloc(n * sizeof(int));
    #####:  328:        int P_new_size = 0;
    #####:  329:        for (int j = 0; j < P_size; j++) {
    #####:  330:            if (adj_matrix[v][P[j]]) {
    #####:  331:                P_new[P_new_size++] = P[j];
        -:  332:            }
        -:  333:        }
        -:  334:        
        -:  335:        // X' = X ∩ N(v)
    #####:  336:        int* X_new = (int*)malloc(n * sizeof(int));
    #####:  337:        int X_new_size = 0;
    #####:  338:        for (int j = 0; j < X_size; j++) {
    #####:  339:            if (adj_matrix[v][X[j]]) {
    #####:  340:                X_new[X_new_size++] = X[j];
        -:  341:            }
        -:  342:        }
        -:  343:        
        -:  344:        // Recursive call
    #####:  345:        bron_kerbosch(adj_matrix, n, R, R_size + 1, P_new, P_new_size, X_new, X_new_size,
        -:  346:                     results, num_results, capacity);
        -:  347:        
        -:  348:        // Move v from P to X
    #####:  349:        for (int j = 0; j < P_size; j++) {
    #####:  350:            if (P[j] == v) {
    #####:  351:                for (int k = j; k < P_size - 1; k++) {
    #####:  352:                    P[k] = P[k + 1];
        -:  353:                }
    #####:  354:                P_size--;
    #####:  355:                break;
        -:  356:            }
        -:  357:        }
    #####:  358:        X[X_size++] = v;
        -:  359:        
    #####:  360:        free(P_new);
    #####:  361:        free(X_new);
        -:  362:    }
        -:  363:    
    #####:  364:    free(P_copy);
        -:  365:}
        -:  366:
        -:  367:/**
        -:  368: * Find all maximal cliques using Bron-Kerbosch algorithm.
        -:  369: */
    #####:  370:int graph_find_all_maximal_cliques(const Graph* g, MaxClique_Result** max_cliques, int* num_cliques) {
    #####:  371:    if (!g || !max_cliques || !num_cliques) return 0;
        -:  372:    
    #####:  373:    int n = g->n;
    #####:  374:    *max_cliques = NULL;
    #####:  375:    *num_cliques = 0;
        -:  376:    
    #####:  377:    if (n == 0) return 1;
        -:  378:    
        -:  379:    // Build adjacency matrix
    #####:  380:    int** adj_matrix = (int**)malloc(n * sizeof(int*));
    #####:  381:    if (!adj_matrix) return 0;
        -:  382:    
    #####:  383:    for (int i = 0; i < n; i++) {
    #####:  384:        adj_matrix[i] = (int*)malloc(n * sizeof(int));
    #####:  385:        if (!adj_matrix[i]) {
    #####:  386:            for (int j = 0; j < i; j++) free(adj_matrix[j]);
    #####:  387:            free(adj_matrix);
    #####:  388:            return 0;
        -:  389:        }
        -:  390:    }
        -:  391:    
    #####:  392:    build_adjacency_matrix(g, adj_matrix);
        -:  393:    
        -:  394:    // Initialize for Bron-Kerbosch
    #####:  395:    int* R = (int*)malloc(n * sizeof(int)); // Current clique (empty)
    #####:  396:    int* P = (int*)malloc(n * sizeof(int)); // All vertices initially
    #####:  397:    int* X = (int*)malloc(n * sizeof(int)); // Excluded vertices (empty)
        -:  398:    
    #####:  399:    if (!R || !P || !X) {
    #####:  400:        free(R); free(P); free(X);
    #####:  401:        for (int i = 0; i < n; i++) free(adj_matrix[i]);
    #####:  402:        free(adj_matrix);
    #####:  403:        return 0;
        -:  404:    }
        -:  405:    
        -:  406:    // Initialize P with all vertices
    #####:  407:    for (int i = 0; i < n; i++) {
    #####:  408:        P[i] = i;
        -:  409:    }
        -:  410:    
    #####:  411:    int capacity = 10;
    #####:  412:    *max_cliques = (MaxClique_Result*)malloc(capacity * sizeof(MaxClique_Result));
    #####:  413:    if (!*max_cliques) {
    #####:  414:        free(R); free(P); free(X);
    #####:  415:        for (int i = 0; i < n; i++) free(adj_matrix[i]);
    #####:  416:        free(adj_matrix);
    #####:  417:        return 0;
        -:  418:    }
        -:  419:    
    #####:  420:    bron_kerbosch(adj_matrix, n, R, 0, P, n, X, 0, max_cliques, num_cliques, &capacity);
        -:  421:    
        -:  422:    // Cleanup
    #####:  423:    free(R); free(P); free(X);
    #####:  424:    for (int i = 0; i < n; i++) free(adj_matrix[i]);
    #####:  425:    free(adj_matrix);
        -:  426:    
    #####:  427:    return 1;
        -:  428:}
