        -:    0:Source:../part7/maxflow.c
        -:    0:Graph:../part7/maxflow.gcno
        -:    0:Data:../part7/maxflow.gcda
        -:    0:Runs:2
        -:    1:#include "maxflow.h"
        -:    2:#include <stdio.h>
        -:    3:#include <stdlib.h>
        -:    4:#include <string.h>
        -:    5:#include <limits.h>
        -:    6:
        -:    7:/**
        -:    8: * Queue implementation for BFS
        -:    9: */
        -:   10:typedef struct {
        -:   11:    int* data;
        -:   12:    int front, rear, size, capacity;
        -:   13:} Queue;
        -:   14:
    #####:   15:static Queue* queue_create(int capacity) {
    #####:   16:    Queue* q = (Queue*)malloc(sizeof(Queue));
    #####:   17:    if (!q) return NULL;
        -:   18:    
    #####:   19:    q->data = (int*)malloc(sizeof(int) * capacity);
    #####:   20:    if (!q->data) {
    #####:   21:        free(q);
    #####:   22:        return NULL;
        -:   23:    }
        -:   24:    
    #####:   25:    q->front = q->rear = q->size = 0;
    #####:   26:    q->capacity = capacity;
    #####:   27:    return q;
        -:   28:}
        -:   29:
    #####:   30:static void queue_destroy(Queue* q) {
    #####:   31:    if (q) {
    #####:   32:        free(q->data);
    #####:   33:        free(q);
        -:   34:    }
    #####:   35:}
        -:   36:
    #####:   37:static int queue_is_empty(const Queue* q) {
    #####:   38:    return q->size == 0;
        -:   39:}
        -:   40:
    #####:   41:static int queue_enqueue(Queue* q, int item) {
    #####:   42:    if (q->size >= q->capacity) return 0; // Queue full
        -:   43:    
    #####:   44:    q->data[q->rear] = item;
    #####:   45:    q->rear = (q->rear + 1) % q->capacity;
    #####:   46:    q->size++;
    #####:   47:    return 1;
        -:   48:}
        -:   49:
    #####:   50:static int queue_dequeue(Queue* q) {
    #####:   51:    if (queue_is_empty(q)) return -1;
        -:   52:    
    #####:   53:    int item = q->data[q->front];
    #####:   54:    q->front = (q->front + 1) % q->capacity;
    #####:   55:    q->size--;
    #####:   56:    return item;
        -:   57:}
        -:   58:
        -:   59:/**
        -:   60: * Convert adjacency list graph to capacity matrix.
        -:   61: * For unweighted graph, each edge has capacity 1.
        -:   62: * 
        -:   63: * @param g Graph pointer
        -:   64: * @param capacity_matrix OUT: nÃ—n matrix to fill with capacities
        -:   65: * @return 1 on success, 0 on failure
        -:   66: */
    #####:   67:static int build_capacity_matrix(const Graph* g, int** capacity_matrix) {
    #####:   68:    int n = g->n;
        -:   69:    
        -:   70:    // Initialize matrix to 0
    #####:   71:    for (int i = 0; i < n; i++) {
    #####:   72:        for (int j = 0; j < n; j++) {
    #####:   73:            capacity_matrix[i][j] = 0;
        -:   74:        }
        -:   75:    }
        -:   76:    
        -:   77:    // Fill capacity matrix from adjacency lists using actual edge weights
    #####:   78:    for (int u = 0; u < n; u++) {
    #####:   79:        for (EdgeNode* edge = g->adj[u].head; edge; edge = edge->next) {
    #####:   80:            int v = edge->to;
    #####:   81:            if (u != v) { // Skip self-loops for flow networks
        -:   82:                // Use edge weight as capacity (instead of hardcoded 1)
    #####:   83:                capacity_matrix[u][v] = edge->weight;
        -:   84:            }
        -:   85:        }
        -:   86:    }
    #####:   87:    return 1;
        -:   88:}
        -:   89:
        -:   90:/**
        -:   91: * BFS to find augmenting path in residual graph.
        -:   92: * 
        -:   93: * @param res_graph Residual graph as capacity matrix
        -:   94: * @param n Number of vertices
        -:   95: * @param source Source vertex
        -:   96: * @param sink Sink vertex
        -:   97: * @param parent OUT: array to store the path
        -:   98: * @return 1 if augmenting path found, 0 otherwise
        -:   99: */
    #####:  100:static int bfs_find_path(int** res_graph, int n, int source, int sink, int* parent) {
    #####:  101:    int* visited = (int*)calloc(n, sizeof(int));
    #####:  102:    if (!visited) return 0;
        -:  103:    
    #####:  104:    Queue* q = queue_create(n);
    #####:  105:    if (!q) {
    #####:  106:        free(visited);
    #####:  107:        return 0;
        -:  108:    }
        -:  109:    
    #####:  110:    queue_enqueue(q, source);
    #####:  111:    visited[source] = 1;
    #####:  112:    parent[source] = -1;
        -:  113:    
    #####:  114:    int found = 0;
        -:  115:    
    #####:  116:    while (!queue_is_empty(q) && !found) {
    #####:  117:        int u = queue_dequeue(q);
        -:  118:        
    #####:  119:        for (int v = 0; v < n; v++) {
    #####:  120:            if (!visited[v] && res_graph[u][v] > 0) {
    #####:  121:                parent[v] = u;
    #####:  122:                visited[v] = 1;
    #####:  123:                queue_enqueue(q, v);
        -:  124:                
    #####:  125:                if (v == sink) {
    #####:  126:                    found = 1;
    #####:  127:                    break;
        -:  128:                }
        -:  129:            }
        -:  130:        }
        -:  131:    }
        -:  132:    
    #####:  133:    queue_destroy(q);
    #####:  134:    free(visited);
    #####:  135:    return found;
        -:  136:}
        -:  137:
        -:  138:/**
        -:  139: * Find minimum value in augmenting path.
        -:  140: */
    #####:  141:static int find_path_flow(int** res_graph, int source, int sink, int* parent) {
    #####:  142:    int path_flow = INT_MAX;
        -:  143:    
    #####:  144:    for (int v = sink; v != source; v = parent[v]) {
    #####:  145:        int u = parent[v];
    #####:  146:        if (res_graph[u][v] < path_flow) {
    #####:  147:            path_flow = res_graph[u][v];
        -:  148:        }
        -:  149:    }
        -:  150:    
    #####:  151:    return path_flow;
        -:  152:}
        -:  153:
        -:  154:/**
        -:  155: * Update residual graph along the augmenting path.
        -:  156: */
    #####:  157:static void update_residual_graph(int** res_graph, int source, int sink, int* parent, int path_flow) {
    #####:  158:    for (int v = sink; v != source; v = parent[v]) {
    #####:  159:        int u = parent[v];
    #####:  160:        res_graph[u][v] -= path_flow;  // Forward edge
    #####:  161:        res_graph[v][u] += path_flow;  // Backward edge
        -:  162:    }
    #####:  163:}
        -:  164:
        -:  165:/**
        -:  166: * Calculate maximum flow from source to sink using Edmonds-Karp algorithm.
        -:  167: */
    #####:  168:int graph_max_flow(const Graph* g, int source, int sink, int* max_flow_value) {
    #####:  169:    if (!g || !max_flow_value || source < 0 || sink < 0 || 
    #####:  170:        source >= g->n || sink >= g->n || source == sink) {
    #####:  171:        return 0;
        -:  172:    }
        -:  173:    
    #####:  174:    int n = g->n;
    #####:  175:    *max_flow_value = 0;
        -:  176:    
        -:  177:    // Allocate capacity/residual matrix
    #####:  178:    int** res_graph = (int**)malloc(n * sizeof(int*));
    #####:  179:    if (!res_graph) return 0;
        -:  180:    
    #####:  181:    for (int i = 0; i < n; i++) {
    #####:  182:        res_graph[i] = (int*)malloc(n * sizeof(int));
    #####:  183:        if (!res_graph[i]) {
        -:  184:            // Cleanup on failure
    #####:  185:            for (int j = 0; j < i; j++) {
    #####:  186:                free(res_graph[j]);
        -:  187:            }
    #####:  188:            free(res_graph);
    #####:  189:            return 0;
        -:  190:        }
        -:  191:    }
        -:  192:    
        -:  193:    // Build initial capacity matrix
    #####:  194:    if (!build_capacity_matrix(g, res_graph)) {
        -:  195:        // Cleanup
    #####:  196:        for (int i = 0; i < n; i++) {
    #####:  197:            free(res_graph[i]);
        -:  198:        }
    #####:  199:        free(res_graph);
    #####:  200:        return 0;
        -:  201:    }
        -:  202:    
    #####:  203:    int* parent = (int*)malloc(n * sizeof(int));
    #####:  204:    if (!parent) {
    #####:  205:        for (int i = 0; i < n; i++) {
    #####:  206:            free(res_graph[i]);
        -:  207:        }
    #####:  208:        free(res_graph);
    #####:  209:        return 0;
        -:  210:    }
        -:  211:    
    #####:  212:    int max_flow = 0;
        -:  213:    
        -:  214:    // Edmonds-Karp main loop
    #####:  215:    while (bfs_find_path(res_graph, n, source, sink, parent)) {
        -:  216:        // Find minimum capacity along the path
    #####:  217:        int path_flow = find_path_flow(res_graph, source, sink, parent);
        -:  218:        
        -:  219:        // Update residual graph
    #####:  220:        update_residual_graph(res_graph, source, sink, parent, path_flow);
        -:  221:        
        -:  222:        // Add path flow to total flow
    #####:  223:        max_flow += path_flow;
        -:  224:    }
        -:  225:    
    #####:  226:    *max_flow_value = max_flow;
        -:  227:    
        -:  228:    // Cleanup
    #####:  229:    free(parent);
    #####:  230:    for (int i = 0; i < n; i++) {
    #####:  231:        free(res_graph[i]);
        -:  232:    }
    #####:  233:    free(res_graph);
        -:  234:    
    #####:  235:    return 1;
        -:  236:}
        -:  237:
        -:  238:/**
        -:  239: * Calculate maximum flow with default source=0 and sink=n-1.
        -:  240: */
    #####:  241:int graph_max_flow_default(const Graph* g, int* max_flow_value) {
    #####:  242:    if (!g || g->n < 2) return 0;
    #####:  243:    return graph_max_flow(g, 0, g->n - 1, max_flow_value);
        -:  244:}
        -:  245:
        -:  246:/**
        -:  247: * Print maximum flow result in a formatted string.
        -:  248: */
    #####:  249:void graph_print_max_flow(const Graph* g, int source, int sink) {
    #####:  250:    if (!g) {
    #####:  251:        printf("Error: NULL graph\n");
    #####:  252:        return;
        -:  253:    }
        -:  254:    
    #####:  255:    if (source < 0 || sink < 0 || source >= g->n || sink >= g->n) {
    #####:  256:        printf("Error: Invalid source (%d) or sink (%d) for graph with %d vertices\n", 
    #####:  257:               source, sink, g->n);
    #####:  258:        return;
        -:  259:    }
        -:  260:    
    #####:  261:    if (source == sink) {
    #####:  262:        printf("Error: Source and sink cannot be the same vertex\n");
    #####:  263:        return;
        -:  264:    }
        -:  265:    
        -:  266:    int max_flow_value;
    #####:  267:    if (graph_max_flow(g, source, sink, &max_flow_value)) {
    #####:  268:        printf("Max flow from vertex %d to vertex %d is: %d\n", 
        -:  269:               source, sink, max_flow_value);
        -:  270:    } else {
    #####:  271:        printf("Failed to calculate max flow from vertex %d to vertex %d\n", 
        -:  272:               source, sink);
        -:  273:    }
        -:  274:}
